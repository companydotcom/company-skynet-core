SNS Worker phases

1. Throttling
2. Get Messages from Queue (Bulk-only)
3. Pre-worker hook (custom middleware?)
4. Throttling Call count?
5. <Start "Process">
6. Get VendorConfig
7. Get ServiceUserData
8. Get ServiceAccountDta
9. Worker Invoked w/ never throw error
10. Set ServiceAccountData
11. Set ServiceUserData
12. SNS CRM Data
13. SNS Extra Status (ABORT continuation)
14. Regular SNS Handled
15. Delete Msg from Queue (Bulk-only)
15. Send to DLQ if worker failed

Begin Throttle
> Handle Bulk (pull from queue)
> > (with SNS Workflow)
> > > Pre-worker (custom)
> > > > (with CRM data)
> > > > > (with Extra Status)
> > > > > > Handle Vendor Config (get)
> > > > > > > Handle Service User/Account (get)
> > > > > > > > Never throw error invoke
> > > > > > > > > Worker (core of call)
> > > > > > > > Never throw error defaults
> > > > > > > Handle Service User/Account (set)
> > > > > > /no set vendorConfig/
> > > > >  with Extra Status
> > > > with CRM Data
> > > Post-worker (custom)
> > with SNS Workflow - Normal SNS re-emit handled
> Handle Bulk (delete from queue)
Adjust Call count

on Error -> Send to DLQ ?

Bulk & Throttle
with Skynet
Custom (pre-worker/post-worker) filter
CRM Data
Extra Status
Vendor Context
User Context
Error Protection
Worker

Bulk & Throttle
with Skynet
VendorContext
UserContext
Error Protection
Worker

We should look into https://middy.js.org/packages/ssm/
when we are going to transition pieces of vendor config into ssm

also validator

import middy from '@middy/core'
import middleware1 from 'sample-middleware1'
import middleware2 from 'sample-middleware2'
import middleware3 from 'sample-middleware3'

const baseHandler = (event, context) => {
  /* your business logic */
}

const handler = middy(baseHandler)

handler
  .use(middleware1())
  .use(middleware2())
  .use(middleware3())

module.exports = { handler }


NOTE
In order to deal with bulk stuff and keep workers as consistently dealing with singletons:
Middy is going to have to be an internal of skynet core and not be wrapping the entire lambda handler - this is a little weird.

Throttling and bulk handling will be external to the middleware with then once messages are fetched the middleware stack being able to deal only with singletons.  This feels like maybe a bit of an anti-pattern but I guess that's what we've got

const worker = (event, context) => {}

const directTransitionHandler = (event) => {
  const msgToHandle = parse(events.Records[0])

  const messageHandler = middy(worker);

  messageHandler.use(skynetCore({}))
  messageHandler.use(...)

  return messageHandler(msgToHandle)
}

const directTransitionHandler = (event) => {
  // compute capacity
  // pull records from queue

  const msgsToHandle = <messages from queue>

  const messageHandler = middy(worker);

  messageHandler.use(skynetCore({}))
  messageHandler.use(...)

  return Promise.all(msgsToHandle.map(m => messageHandler(m)))
}

Alternatively - the worker would not be the core "handler" but rather a map function with the worker as the iterator.  (I think this is the way to go) - however it means that all middlewares have to deal with arrays of messages - in some cases, where there is an operation that would be the same for all records (like fetching vendorConfig) makes sense, but feels cumbersome and makes error handling a little weird to have to assume you're always dealing with many messages at once when that is not really the standard

const worker = (event, context) => {}

const directTransitionHandler = middy((request, context) => {
  return Promise.all(
    request.messagesToProcess(m => neverThrowError(worker(
      m.message,
      context.vendorConfig,
      m.serviceAccountData,
      m.serviceUserData,
      m.attributes
    )))
  )
})

directTransitionHandler.use(skynetCore({
  eventType: 'fetch',
  isBulk: false,
  ...throttle params
}))

export default directTransitionHandler;  // actual lambda handler